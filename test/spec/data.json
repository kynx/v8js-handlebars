[
	{
		"description": "data",
		"it": "passing in data to a compiled function that expects data - works with helpers",
		"template": "{{hello}}",
		"data": {
			"noun": "cat"
		},
		"expected": "happy cat",
		"message": "Data output by helper",
		"options": {
			"data": {
				"adjective": "happy"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.data.adjective + ' ' + this.noun;\n      }",
				"phpstub": "function (options) {\n        return options.data.adjective + ' ' + this.noun;\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "data can be looked up via @foo",
		"template": "{{@hello}}",
		"data": {},
		"expected": "hello",
		"message": "@foo retrieves template data",
		"options": {
			"data": {
				"hello": "hello"
			}
		}
	},
	{
		"description": "data",
		"it": "deep @foo triggers automatic top-level data",
		"template": "{{#let world=\"world\"}}{{#if foo}}{{#if foo}}Hello {{@world}}{{/if}}{{/if}}{{/let}}",
		"data": {
			"foo": true
		},
		"expected": "Hello world",
		"message": "Automatic data was triggered",
		"helpers": {
			"blockHelperMissing": {
				"!code": true,
				"javascript": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }",
				"phpstub": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }"
			},
			"each": {
				"!code": true,
				"javascript": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      // Don't iterate over undefined values since we can't execute blocks against them\n      // in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            // We're running the iterations one step out of sync so we can detect\n            // the last iteration without have to scan the object twice and create\n            // an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }",
				"phpstub": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      // Don't iterate over undefined values since we can't execute blocks against them\n      // in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            // We're running the iterations one step out of sync so we can detect\n            // the last iteration without have to scan the object twice and create\n            // an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }"
			},
			"helperMissing": {
				"!code": true,
				"javascript": "function () /* [args, ]options */{\n    if (arguments.length === 1) {\n      // A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }",
				"phpstub": "function () /* [args, ]options */{\n    if (arguments.length === 1) {\n      // A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }"
			},
			"if": {
				"!code": true,
				"javascript": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }",
				"phpstub": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }"
			},
			"unless": {
				"!code": true,
				"javascript": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }",
				"phpstub": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }"
			},
			"log": {
				"!code": true,
				"javascript": "function () /* message, options */{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }",
				"phpstub": "function () /* message, options */{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }"
			},
			"lookup": {
				"!code": true,
				"javascript": "function (obj, field) {\n    return obj && obj[field];\n  }",
				"phpstub": "function (obj, field) {\n    return obj && obj[field];\n  }"
			},
			"with": {
				"!code": true,
				"javascript": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }",
				"phpstub": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }"
			},
			"let": {
				"!code": true,
				"javascript": "function (options) {\n      var frame = Handlebars.createFrame(options.data);\n\n      for (var prop in options.hash) {\n        if (prop in options.hash) {\n          frame[prop] = options.hash[prop];\n        }\n      }\n      return options.fn(this, { data: frame });\n    }",
				"phpstub": "function (options) {\n      var frame = Handlebars.createFrame(options.data);\n\n      for (var prop in options.hash) {\n        if (prop in options.hash) {\n          frame[prop] = options.hash[prop];\n        }\n      }\n      return options.fn(this, { data: frame });\n    }"
			}
		}
	},
	{
		"description": "data",
		"it": "parameter data can be looked up via @foo",
		"template": "{{hello @world}}",
		"data": {},
		"expected": "Hello world",
		"message": "@foo as a parameter retrieves template data",
		"options": {
			"data": {
				"world": "world"
			}
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (noun) {\n        return 'Hello ' + noun;\n      }",
				"phpstub": "function (noun) {\n        return 'Hello ' + noun;\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "hash values can be looked up via @foo",
		"template": "{{hello noun=@world}}",
		"data": {},
		"expected": "Hello world",
		"message": "@foo as a parameter retrieves template data",
		"options": {
			"data": {
				"world": "world"
			}
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return 'Hello ' + options.hash.noun;\n      }",
				"phpstub": "function (options) {\n        return 'Hello ' + options.hash.noun;\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "nested parameter data can be looked up via @foo.bar",
		"template": "{{hello @world.bar}}",
		"data": {},
		"expected": "Hello world",
		"message": "@foo as a parameter retrieves template data",
		"options": {
			"data": {
				"world": {
					"bar": "world"
				}
			}
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (noun) {\n        return 'Hello ' + noun;\n      }",
				"phpstub": "function (noun) {\n        return 'Hello ' + noun;\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "nested parameter data does not fail with @world.bar",
		"template": "{{hello @world.bar}}",
		"data": {},
		"expected": "Hello undefined",
		"message": "@foo as a parameter retrieves template data",
		"options": {
			"data": {
				"foo": {
					"bar": "world"
				}
			}
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (noun) {\n        return 'Hello ' + noun;\n      }",
				"phpstub": "function (noun) {\n        return 'Hello ' + noun;\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "parameter data throws when using complex scope references",
		"template": "{{#goodbyes}}{{text}} cruel {{@foo/../name}}! {{/goodbyes}}",
		"exception": true
	},
	{
		"description": "data",
		"it": "data can be functions",
		"template": "{{@hello}}",
		"data": {},
		"expected": "hello",
		"options": {
			"data": {
				"hello": {
					"!code": true,
					"javascript": "function () { return 'hello'; }",
					"phpstub": "function () { return 'hello'; }"
				}
			}
		}
	},
	{
		"description": "data",
		"it": "data can be functions with params",
		"template": "{{@hello \"hello\"}}",
		"data": {},
		"expected": "hello",
		"options": {
			"data": {
				"hello": {
					"!code": true,
					"javascript": "function (arg) { return arg; }",
					"phpstub": "function (arg) { return arg; }"
				}
			}
		}
	},
	{
		"description": "data",
		"it": "data is inherited downstream",
		"template": "{{#let foo=1 bar=2}}{{#let foo=bar.baz}}{{@bar}}{{@foo}}{{/let}}{{@foo}}{{/let}}",
		"data": {
			"bar": {
				"baz": "hello world"
			}
		},
		"expected": "2hello world1",
		"message": "data variables are inherited downstream",
		"options": {
			"data": {}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"let": {
				"!code": true,
				"javascript": "function (options) {\n        var frame = Handlebars.createFrame(options.data);\n        for (var prop in options.hash) {\n          if (prop in options.hash) {\n            frame[prop] = options.hash[prop];\n          }\n        }\n        return options.fn(this, {data: frame});\n      }",
				"phpstub": "function (options) {\n        var frame = Handlebars.createFrame(options.data);\n        for (var prop in options.hash) {\n          if (prop in options.hash) {\n            frame[prop] = options.hash[prop];\n          }\n        }\n        return options.fn(this, {data: frame});\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "passing in data to a compiled function that expects data - works with helpers in partials",
		"template": "{{hello}}",
		"data": {
			"noun": "cat"
		},
		"expected": "happy cat",
		"message": "Data output by helper inside partial",
		"options": {
			"data": {
				"adjective": "happy",
				"_parent": {
					"adjective": "happy"
				},
				"root": {
					"noun": "cat"
				}
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"blockHelperMissing": {
				"!code": true,
				"javascript": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }",
				"phpstub": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }"
			},
			"each": {
				"!code": true,
				"javascript": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      // Don't iterate over undefined values since we can't execute blocks against them\n      // in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            // We're running the iterations one step out of sync so we can detect\n            // the last iteration without have to scan the object twice and create\n            // an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }",
				"phpstub": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      // Don't iterate over undefined values since we can't execute blocks against them\n      // in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            // We're running the iterations one step out of sync so we can detect\n            // the last iteration without have to scan the object twice and create\n            // an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }"
			},
			"helperMissing": {
				"!code": true,
				"javascript": "function () /* [args, ]options */{\n    if (arguments.length === 1) {\n      // A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }",
				"phpstub": "function () /* [args, ]options */{\n    if (arguments.length === 1) {\n      // A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }"
			},
			"if": {
				"!code": true,
				"javascript": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }",
				"phpstub": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }"
			},
			"unless": {
				"!code": true,
				"javascript": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }",
				"phpstub": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }"
			},
			"log": {
				"!code": true,
				"javascript": "function () /* message, options */{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }",
				"phpstub": "function () /* message, options */{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }"
			},
			"lookup": {
				"!code": true,
				"javascript": "function (obj, field) {\n    return obj && obj[field];\n  }",
				"phpstub": "function (obj, field) {\n    return obj && obj[field];\n  }"
			},
			"with": {
				"!code": true,
				"javascript": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }",
				"phpstub": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }"
			},
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.data.adjective + ' ' + this.noun;\n      }",
				"phpstub": "function (options) {\n        return options.data.adjective + ' ' + this.noun;\n      }"
			}
		},
		"decorators": {
			"inline": {
				"!code": true,
				"javascript": "function (fn, props, container, options) {\n    var ret = fn;\n    if (!props.partials) {\n      props.partials = {};\n      ret = function (context, options) {\n        // Create a new partials stack frame prior to exec.\n        var original = container.partials;\n        container.partials = _utils.extend({}, original, props.partials);\n        var ret = fn(context, options);\n        container.partials = original;\n        return ret;\n      };\n    }\n\n    props.partials[options.args[0]] = options.fn;\n\n    return ret;\n  }",
				"phpstub": "function (fn, props, container, options) {\n    var ret = fn;\n    if (!props.partials) {\n      props.partials = {};\n      ret = function (context, options) {\n        // Create a new partials stack frame prior to exec.\n        var original = container.partials;\n        container.partials = _utils.extend({}, original, props.partials);\n        var ret = fn(context, options);\n        container.partials = original;\n        return ret;\n      };\n    }\n\n    props.partials[options.args[0]] = options.fn;\n\n    return ret;\n  }"
			}
		}
	},
	{
		"description": "data",
		"it": "passing in data to a compiled function that expects data - works with helpers and parameters",
		"template": "{{hello world}}",
		"data": {
			"exclaim": true,
			"world": "world"
		},
		"expected": "happy world!",
		"message": "Data output by helper",
		"options": {
			"data": {
				"adjective": "happy"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (noun, options) {\n        return options.data.adjective + ' ' + noun + (this.exclaim ? '!' : '');\n      }",
				"phpstub": "function (noun, options) {\n        return options.data.adjective + ' ' + noun + (this.exclaim ? '!' : '');\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "passing in data to a compiled function that expects data - works with block helpers",
		"template": "{{#hello}}{{world}}{{/hello}}",
		"data": {
			"exclaim": true
		},
		"expected": "happy world!",
		"message": "Data output by helper",
		"options": {
			"data": {
				"adjective": "happy"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.fn(this);\n      }",
				"phpstub": "function (options) {\n        return options.fn(this);\n      }"
			},
			"world": {
				"!code": true,
				"javascript": "function (options) {\n        return options.data.adjective + ' world' + (this.exclaim ? '!' : '');\n      }",
				"phpstub": "function (options) {\n        return options.data.adjective + ' world' + (this.exclaim ? '!' : '');\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "passing in data to a compiled function that expects data - works with block helpers that use ..",
		"template": "{{#hello}}{{world ../zomg}}{{/hello}}",
		"data": {
			"exclaim": true,
			"zomg": "world"
		},
		"expected": "happy world?",
		"message": "Data output by helper",
		"options": {
			"data": {
				"adjective": "happy"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.fn({exclaim: '?'});\n      }",
				"phpstub": "function (options) {\n        return options.fn({exclaim: '?'});\n      }"
			},
			"world": {
				"!code": true,
				"javascript": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }",
				"phpstub": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "passing in data to a compiled function that expects data - data is passed to with block helpers where children use ..",
		"template": "{{#hello}}{{world ../zomg}}{{/hello}}",
		"data": {
			"exclaim": true,
			"zomg": "world"
		},
		"expected": "#win happy world?",
		"message": "Data output by helper",
		"options": {
			"data": {
				"adjective": "happy",
				"accessData": "#win"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.data.accessData + ' ' + options.fn({exclaim: '?'});\n      }",
				"phpstub": "function (options) {\n        return options.data.accessData + ' ' + options.fn({exclaim: '?'});\n      }"
			},
			"world": {
				"!code": true,
				"javascript": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }",
				"phpstub": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "you can override inherited data when invoking a helper",
		"template": "{{#hello}}{{world zomg}}{{/hello}}",
		"data": {
			"exclaim": true,
			"zomg": "planet"
		},
		"expected": "sad world?",
		"message": "Overriden data output by helper",
		"options": {
			"data": {
				"adjective": "happy"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.fn({exclaim: '?', zomg: 'world'}, { data: {adjective: 'sad'} });\n      }",
				"phpstub": "function (options) {\n        return options.fn({exclaim: '?', zomg: 'world'}, { data: {adjective: 'sad'} });\n      }"
			},
			"world": {
				"!code": true,
				"javascript": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }",
				"phpstub": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }"
			}
		}
	},
	{
		"description": "data",
		"it": "you can override inherited data when invoking a helper with depth",
		"template": "{{#hello}}{{world ../zomg}}{{/hello}}",
		"data": {
			"exclaim": true,
			"zomg": "world"
		},
		"expected": "sad world?",
		"message": "Overriden data output by helper",
		"options": {
			"data": {
				"adjective": "happy"
			}
		},
		"compileOptions": {
			"data": true
		},
		"helpers": {
			"hello": {
				"!code": true,
				"javascript": "function (options) {\n        return options.fn({exclaim: '?'}, { data: {adjective: 'sad'} });\n      }",
				"phpstub": "function (options) {\n        return options.fn({exclaim: '?'}, { data: {adjective: 'sad'} });\n      }"
			},
			"world": {
				"!code": true,
				"javascript": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }",
				"phpstub": "function (thing, options) {\n        return options.data.adjective + ' ' + thing + (this.exclaim || '');\n      }"
			}
		}
	},
	{
		"description": "@root",
		"it": "the root context can be looked up via @root",
		"template": "{{@root.foo}}",
		"data": {
			"foo": "hello"
		},
		"expected": "hello",
		"options": {
			"data": {}
		}
	},
	{
		"description": "@root",
		"it": "the root context can be looked up via @root",
		"template": "{{@root.foo}}",
		"data": {
			"foo": "hello"
		},
		"expected": "hello"
	},
	{
		"description": "@root",
		"it": "passed root values take priority",
		"template": "{{@root.foo}}",
		"data": {},
		"expected": "hello",
		"options": {
			"data": {
				"root": {
					"foo": "hello"
				}
			}
		}
	},
	{
		"description": "nesting",
		"it": "the root context can be looked up via @root",
		"template": "{{#helper}}{{#helper}}{{@./depth}} {{@../depth}} {{@../../depth}}{{/helper}}{{/helper}}",
		"data": {
			"foo": "hello"
		},
		"expected": "2 1 0",
		"options": {
			"data": {
				"depth": 0
			}
		},
		"helpers": {
			"helper": {
				"!code": true,
				"javascript": "function (options) {\n            var frame = Handlebars.createFrame(options.data);\n            frame.depth = options.data.depth + 1;\n            return options.fn(this, {data: frame});\n          }",
				"phpstub": "function (options) {\n            var frame = Handlebars.createFrame(options.data);\n            frame.depth = options.data.depth + 1;\n            return options.fn(this, {data: frame});\n          }"
			}
		}
	}
]