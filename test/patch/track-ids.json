{
    "#blockhelpermissing-should handle nesting-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#blockhelpermissing-should track contextpath for arrays-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#blockhelpermissing-should track contextpath for keys-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#each-should handle block params-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#each-should handle nesting-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#each-should track contextpath for arrays-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#each-should track contextpath for keys-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#with-should handle nesting-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "#with-should track contextpath-00": {
        "helpers": {
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        }
    },
    "partials-should invalidate context for partials with parameters-00": {
        "helpers": {
            "blockHelperMissing": {
                "phpstub": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }"
            },
            "each": {
                "phpstub": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      \/\/ Don't iterate over undefined values since we can't execute blocks against them\n      \/\/ in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            \/\/ We're running the iterations one step out of sync so we can detect\n            \/\/ the last iteration without have to scan the object twice and create\n            \/\/ an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }"
            },
            "helperMissing": {
                "phpstub": "function () \/* [args, ]options *\/{\n    if (arguments.length === 1) {\n      \/\/ A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      \/\/ Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }"
            },
            "if": {
                "phpstub": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    \/\/ Default behavior is to render the positive path if the value is truthy and not empty.\n    \/\/ The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    \/\/ behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }"
            },
            "unless": {
                "phpstub": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }"
            },
            "log": {
                "phpstub": "function () \/* message, options *\/{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }"
            },
            "lookup": {
                "phpstub": "function (obj, field) {\n    return obj && obj[field];\n  }"
            },
            "with": {
                "phpstub": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }"
            },
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        },
        "decorators": {
            "inline": {
                "phpstub": "function (fn, props, container, options) {\n    var ret = fn;\n    if (!props.partials) {\n      props.partials = {};\n      ret = function (context, options) {\n        \/\/ Create a new partials stack frame prior to exec.\n        var original = container.partials;\n        container.partials = _utils.extend({}, original, props.partials);\n        var ret = fn(context, options);\n        container.partials = original;\n        return ret;\n      };\n    }\n\n    props.partials[options.args[0]] = options.fn;\n\n    return ret;\n  }"
            }
        }
    },
    "partials-should pass track id for basic partial-00": {
        "helpers": {
            "blockHelperMissing": {
                "phpstub": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }"
            },
            "each": {
                "phpstub": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      \/\/ Don't iterate over undefined values since we can't execute blocks against them\n      \/\/ in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            \/\/ We're running the iterations one step out of sync so we can detect\n            \/\/ the last iteration without have to scan the object twice and create\n            \/\/ an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }"
            },
            "helperMissing": {
                "phpstub": "function () \/* [args, ]options *\/{\n    if (arguments.length === 1) {\n      \/\/ A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      \/\/ Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }"
            },
            "if": {
                "phpstub": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    \/\/ Default behavior is to render the positive path if the value is truthy and not empty.\n    \/\/ The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    \/\/ behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }"
            },
            "unless": {
                "phpstub": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }"
            },
            "log": {
                "phpstub": "function () \/* message, options *\/{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }"
            },
            "lookup": {
                "phpstub": "function (obj, field) {\n    return obj && obj[field];\n  }"
            },
            "with": {
                "phpstub": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }"
            },
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        },
        "decorators": {
            "inline": {
                "phpstub": "function (fn, props, container, options) {\n    var ret = fn;\n    if (!props.partials) {\n      props.partials = {};\n      ret = function (context, options) {\n        \/\/ Create a new partials stack frame prior to exec.\n        var original = container.partials;\n        container.partials = _utils.extend({}, original, props.partials);\n        var ret = fn(context, options);\n        container.partials = original;\n        return ret;\n      };\n    }\n\n    props.partials[options.args[0]] = options.fn;\n\n    return ret;\n  }"
            }
        }
    },
    "partials-should pass track id for context partial-00": {
        "helpers": {
            "blockHelperMissing": {
                "phpstub": "function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  }"
            },
            "each": {
                "phpstub": "function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      \/\/ Don't iterate over undefined values since we can't execute blocks against them\n      \/\/ in non-strict (js) mode.\n      if (context[field] == null) {\n        return;\n      }\n\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            \/\/ We're running the iterations one step out of sync so we can detect\n            \/\/ the last iteration without have to scan the object twice and create\n            \/\/ an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  }"
            },
            "helperMissing": {
                "phpstub": "function () \/* [args, ]options *\/{\n    if (arguments.length === 1) {\n      \/\/ A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      \/\/ Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  }"
            },
            "if": {
                "phpstub": "function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    \/\/ Default behavior is to render the positive path if the value is truthy and not empty.\n    \/\/ The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    \/\/ behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  }"
            },
            "unless": {
                "phpstub": "function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  }"
            },
            "log": {
                "phpstub": "function () \/* message, options *\/{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  }"
            },
            "lookup": {
                "phpstub": "function (obj, field) {\n    return obj && obj[field];\n  }"
            },
            "with": {
                "phpstub": "function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  }"
            },
            "blockParams": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.ids[0] + '\\n';\n      }"
            },
            "wycats": {
                "phpstub": "function (name, options) {\n        return name + ':' + options.data.contextPath + '\\n';\n      }"
            }
        },
        "decorators": {
            "inline": {
                "phpstub": "function (fn, props, container, options) {\n    var ret = fn;\n    if (!props.partials) {\n      props.partials = {};\n      ret = function (context, options) {\n        \/\/ Create a new partials stack frame prior to exec.\n        var original = container.partials;\n        container.partials = _utils.extend({}, original, props.partials);\n        var ret = fn(context, options);\n        container.partials = original;\n        return ret;\n      };\n    }\n\n    props.partials[options.args[0]] = options.fn;\n\n    return ret;\n  }"
            }
        }
    },
    "track ids-should include argument ids-00": {
        "helpers": {
            "wycats": {
                "phpstub": "function (passiveVoice, noun, options) {\n        equal(options.ids[0], 'is.a');\n        equal(options.ids[1], 'slave.driver');\n\n        return 'HELP ME MY BOSS ' + options.ids[0] + ':' + passiveVoice + ' ' + options.ids[1] + ':' + noun;\n      }"
            }
        }
    },
    "track ids-should include hash ids-00": {
        "helpers": {
            "wycats": {
                "phpstub": "function (options) {\n        equal(options.hashIds.bat, 'is.a');\n        equal(options.hashIds.baz, 'slave.driver');\n\n        return 'HELP ME MY BOSS ' + options.hashIds.bat + ':' + options.hash.bat + ' ' + options.hashIds.baz + ':' + options.hash.baz;\n      }"
            }
        }
    },
    "track ids-should not include anything without the flag-00": {
        "helpers": {
            "wycats": {
                "phpstub": "function (passiveVoice, noun, options) {\n        equal(options.ids, undefined);\n        equal(options.hashIds, undefined);\n\n        return 'success';\n      }"
            }
        }
    },
    "track ids-should note ..\/ and .\/ references-00": {
        "helpers": {
            "wycats": {
                "phpstub": "function (passiveVoice, noun, thiz, thiz2, options) {\n        equal(options.ids[0], 'is.a');\n        equal(options.ids[1], '..\/slave.driver');\n        equal(options.ids[2], 'is.a');\n        equal(options.ids[3], '');\n\n        return 'HELP ME MY BOSS ' + options.ids[0] + ':' + passiveVoice + ' ' + options.ids[1] + ':' + noun;\n      }"
            }
        }
    },
    "track ids-should note @data references-00": {
        "helpers": {
            "wycats": {
                "phpstub": "function (passiveVoice, noun, options) {\n        equal(options.ids[0], '@is.a');\n        equal(options.ids[1], '@slave.driver');\n\n        return 'HELP ME MY BOSS ' + options.ids[0] + ':' + passiveVoice + ' ' + options.ids[1] + ':' + noun;\n      }"
            }
        }
    },
    "track ids-should return null for constants-00": {
        "helpers": {
            "wycats": {
                "phpstub": "function (passiveVoice, noun, options) {\n        equal(options.ids[0], null);\n        equal(options.ids[1], null);\n        equal(options.hashIds.key, null);\n\n        return 'HELP ME MY BOSS ' + passiveVoice + ' ' + noun + ' ' + options.hash.key;\n      }"
            }
        }
    },
    "track ids-should return true for subexpressions-00": {
        "helpers": {
            "sub": {
                "phpstub": "function () { return 1; }"
            },
            "wycats": {
                "phpstub": "function (passiveVoice, options) {\n        equal(options.ids[0], true);\n\n        return 'HELP ME MY BOSS ' + passiveVoice;\n      }"
            }
        }
    },
    "track ids-should use block param paths-00": {
        "helpers": {
            "doIt": {
                "phpstub": "function (options) {\n        var blockParams = [this.is];\n        blockParams.path = ['zomg'];\n        return options.fn(this, {blockParams: blockParams});\n      }"
            },
            "wycats": {
                "phpstub": "function (passiveVoice, noun, blah, options) {\n        equal(options.ids[0], 'zomg.a');\n        equal(options.ids[1], 'slave.driver');\n        equal(options.ids[2], 'zomg');\n\n        return 'HELP ME MY BOSS ' + options.ids[0] + ':' + passiveVoice + ' ' + options.ids[1] + ':' + noun;\n      }"
            }
        }
    }
}